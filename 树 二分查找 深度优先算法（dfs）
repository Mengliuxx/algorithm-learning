一、二分查找
    a. 查找序列需要时单调的（递增或者递减）
    b. 时间复杂度为O(logN)
    c. 利用左闭右开区间描述，代码会很优雅[lb, ub)

    代码：
        while(ub -lb > 1) {
            int mid = (ub + lb) / 2;
            if (Check mid) {  //根据nums[mid]来判断搜索左半部分还是右半部分
                lb = mid;
            } else {
                ub = mid;
            }
        }
        // 视情况处理最后的lb或者ub，此时ub = lb + 1

二、深度优先搜素dfs
    1.通过在状态空间内搜素答案，最终返回结果，需要防止重复搜素导致时间超限，一般数据量比较小，美名暴力搜素。
    2.采用自顶向下的思想，可以转换成自底向上的动态规划算法，避免超时，在树、图遍历的算法也有深度优先搜素的影子。

    代码：
        int dfs(int stat...) {
            if (is ending) {  //注意搜索的边界状态
                return xx;
            }
            ...  // 枚举可能的状态
            int result = dfs(stat...); // 搜素下一步空间
            ...
            return result;
        }

    一般可能会超时，可以采用一个数组记搜素过的状态，
    当搜素过直接返回值，而不是继续搜素，也称为记忆化搜索。
